#задание ЕГЭ2021 - 18. https://labs-org.ru/ege-18/
#Квадрат разлинован на N×N клеток (1 < N < 17). Исполнитель
#Робот может перемещаться по клеткам, выполняя за одно перемещение
# одну из двух команд: вправо или вниз. По команде вправо
# Робот перемещается в соседнюю правую клетку, по команде вниз
# – в соседнюю нижнюю. При попытке выхода за границу квадрата Робот
# разрушается. Перед каждым запуском Робота в каждой клетке квадрата
# лежит монета достоинством от 1 до 100. Посетив клетку, Робот
# забирает монету с собой; это также относится к начальной и конечной
# клетке маршрута Робота.
# Определите максимальную и минимальную денежную сумму,
# которую может собрать Робот, пройдя из левой верхней клетки в правую нижнюю.
# В ответе укажите два числа – сначала максимальную сумму, затем минимальную.
def printMatrix(m): #подпрограмма для вывода матрицы на дисплей
    for i in range(0,len(m[0])):
        for j in range(0,n):
            print(m[i][j],end='\t')
        print('')
def randMatrix(n):  #подпрограмма для генерации матрицы случайных чисел с р-тью n
    import random   #импортируем библиотеку рандом
    random.seed() #инициализация генератора случайных чисел
    m=[[0]*n for i in range(n)]          #пустая матрица c 0 нужного размера
    for i in range(n):                   #заполняем матрицу случайными числами
        for j in range(n):
            m[i][j]=random.randint(1,99)
    #printMatrix(m)
    return(m)

#Тестовые значени из варианта КИМ:
n=10
m=[[51,21,93,48,45,100,67,39,18,29],[57,48,97,51,92,10,93,32,19,58],[63,16,31,16,78,88,90,72,37,67],[10,57,64,25,96,50,81,65,91,69],[99,43,95,7,40,76,18,34,5,65],[35,19,71,77,64,38,62,56,10,2],[100,57,27,26,51,33,100,11,53,1],[11,79,49,46,37,69,80,31,25,39],[22,71,20,23,11,12,39,16,64,34],[4,25,87,84,30,48,77,23,40,33]]
new=[[0]*n for i in range(n)]
n-=1 #для удобства индексации в массивах
#Начинаем составлять матрицу стоимости пути с конца (верхний правый элемент)
#Рассмотрим верхний правый угол матрицы m[0][n]: робот окажется
#тут в любом случае, просто присваиваем соответствующей ячейке
#новой матрицы значение из исходной матрицы:
new[0][n]=m[0][n]
#в эту ячейку можно попасть из m[n-1][n], либо из m[1][n]
#теперь рассмотрим ячейку m[n-1][n]. Из нее можно попасть
#только в крайнюю справа верхнюю ячейку. Поэтому, складываем
#в эту ячейку значение из исходной таблицы + крайней ячейки
new[0][n-1]=m[0][n-1]+new[0][n]
#для элементов верхней строки справедливо, что из них можно
#попасть только в ячейки справа, поэтому,мы вычисляем путь как
#стоимость ячейки из старой матрицы + значение из ячейки новой
#матрицы, лежащей справа:
for j in range(n-1,-1,-1):
    new[0][j]=m[0][j]+new[0][j+1]
#теперь рассмотрим ячейку снизу от крайней правой, т.е. m[1][n]
#робот пройдет через эту клетку и соберет тут монету, и затем
#пойдет в клетку m[0][n], суммируем эти стоимости:
new[1][n]=m[1][n]+new[0][n]
#далее, рассмотрим все ячейки крайнего столбца справа.
#в каждой из них можно двигаться только вверх, суммируем их стоимости
#двигаемся сверху-вниз:
for i in range(1,n+1):
    new[i][n]=m[i][n]+new[i-1][n]
#теперь рассмотрим ячейку, лежащую на диагонали (справа-снизу) от крайней
#верхней ячейки. Робот точно соберет в ней монету, а затем он
# может продолжить движение либо вверх, либо вправо и, в зависимости
# от того ищем ли мы максимум или минимум, мы будем выбирать направление
#давайте сначала найдем максимальную стоимость пути:
new[1][n-1]+=m[1][n-1]+max(new[0][n-1],new[1][n])
# логика предыдущего действия справедлива для всех прочих клеток матрицы
# поэтому, запускаем цикл по всем оставшимся клеткам
for i in range(1,n+1):
    for j in range(n-1,-1,-1):
        new[i][j]=m[i][j]+max(new[i-1][j],new[i][j+1])
# самый дорогой путь, который мы могли получить:
print('maximum = ',new[n][0])
# вернемся на два шага назад и найдем самый дешевый путь:
new[1][n-1]+=m[1][n-1]+min(new[0][n-1],new[1][n])
# логика предыдущего действия справедлива для всех прочих клеток матрицы
# поэтому, запускаем цикл по всем оставшимся клеткам
for i in range(1,n+1):
    for j in range(n-1,-1,-1):
        new[i][j]=m[i][j]+min(new[i-1][j],new[i][j+1])
print('minimum = ', new[n][0])

