# Системный администратор раз в неделю создаёт архив пользовательских файлов. Однако объём диска, куда он помещает архив,
# может быть меньше, чем суммарный объём архивируемых файлов.
# Известно, какой объём занимает файл каждого пользователя.
# По заданной информации об объёме файлов пользователей и свободном объёме на архивном диске определите максимальное число
# пользователей, чьи файлы можно сохранить в архиве, а также максимальный размер имеющегося файла, который может быть сохранён
# в архиве, при условии, что сохранены файлы максимально возможного числа пользователей.
#
# Входные данные.
# В первой строке входного файла находятся два числа: S – размер свободного места на диске (натуральное число, не превышающее
# 10 000) и N – количество пользователей (натуральное число, не превышающее 1000). В следующих N строках находятся значения
# объёмов файлов каждого пользователя (все числа натуральные, не превышающие 100), каждое в отдельной строке.
#
# Запишите в ответе два числа: сначала наибольшее число пользователей, чьи файлы могут быть помещены в архив,
# атем максимальный размер имеющегося файла, который может быть сохранён в архиве, при условии, что сохранены файлы
# максимально возможного числа пользователей.
import random  # импортируем библиотеку рандом
random.seed()  # инициализация генератора случайных чисел
def createRandomFile(): #генератор файлов для задания
    with open('e26.txt','w') as f:
        S=100+random.randint(0,9900) #случайный объем диска
        N=2+random.randint(0,998)    #случайное кол-во пользователей
        f.write(str(S)+'\t')
        f.write(str(N)+'\t')
        for i in range(0,N):
            f.write(str(random.randint(1,100))+'\t') #почему-то не добавляется \n, закрывается файл для записи
def createExampleFile():
    with open('e26.txt', 'w') as f:
        f.write(str(100) + '\t')
        f.write(str(4) + '\t')
        f.write(str(80) + '\t')
        f.write(str(30) + '\t')
        f.write(str(50) + '\t')
        f.write(str(40) + '\t')

#createRandomFile()
createExampleFile()
#открываем файл для чтения
with open('e26.txt','r') as f:
    file=f.readline().split()
    print(file)
#читаем данные из файла
s=int(file[0])  #объем памяти
n=int(file[1])  #кол-во пользователей
del(file[0])    #удаляем ненужные данные из файла
del(file[0])    #удаляем ненужные данные из файла
print(s,'\n',n)
#преобразуем текстовые значение в целочисленные
for i in range(0,len(file)):
    file[i]=int(file[i])
#Логика следующая: чтобы поместить как можно больше файлов в память, нужно брать файлы наименьшего размера. Для этого
# сортируем массив и начинаем заполнять объем памяти самыми маленькими элементами до тех пор, пока есть свободное место
# на диске
file=sorted(file)
print(file)
#начинаем заполнять наш диск, вычисляя общий объем, который занимают файлы
disk=0
for i in range(0,len(file)):
    if disk+(file[i]) >s: break #если при добавлении очередного файла мы переполнили диск, прерываем сохранение
    else: disk+=file[i] #добавляем объем файла к диску
#после завершенияч заополнения диска, в переменной i сохранится количество файлов, записанных на диск
print('i=',i) #это ответ на 1 вопрос
#запомним это кол-во для будущих вычислений:
count = 0
count+=i
#после заполнения диска, возможно останется некоторый "запас" места на диске, например если бы диск имел
#объем 100 мб, мы бы положили на него файлы объемом 50мб и 40 мб, запас бы составли 10. Давайте вычислим этот запас:
reserve=s-disk
print('reserve=',reserve)
#максимальный объем файла, который мы можем записать на диск  при выполнении
# прочих условий =  объем самого большого записанного файла + запас. Давайте найдем подходящий элемент.
#теперь выберем из массива объемов пользовательских файлов те, которые могут быть выбраны в кач-ве самого "тяжелого" файла:
for i in range(0,len(file)):
    if (file[i]-file[count-1]<=reserve):
        maxfile=file[i]
print('maxfile=',maxfile)
